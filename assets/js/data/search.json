[ { "title": "StackFromEnd 가 의도와 다르게 동작했던 일", "url": "/posts/recycler_view_with_stack_from_end/", "categories": "Android, View", "tags": "android, recyclerview, stackfromend, constraintlayout", "date": "2022-01-28 22:00:00 +0900", "snippet": "아래 조건을 만족하는 화면을 개발 중이었습니다. (우리가 흔히 쓰는 메신저 같은)요구사항0. 목록에는 메시지들이 있습니다.1. 첫 진입시 가장 아래있는 (최근) 메시지부터 보여준다. (스크롤 최하단)2. RecyclerView 에 아이템을 추가하면 아래로 쌓인다.여기서 1번 요구사항을 만족하기 위해 우리는 보통 setStackFromEnd(true); 를 사용합니다.private void initRecyclerView() { final LinearLayoutManager linearLayoutManager = new LinearLayoutManager(context); linearLayoutManager.setStackFromEnd(true); binding.messageList.setLayoutManager(linearLayoutManager); binding.messageList.setAdapter(adapter);}LinearLayoutManager 의 StackFromEnd 를 설정해주면 아주 간단히 해결됩니다.될 줄 알았는데, 한가지 이슈가 있었습니다.문제상황아래와 같은 layout 에서 stackFromEnd 는 올바르게 동작할까요?(이번 이슈와 무관한 부분은 과감히 뺐습니다)&amp;lt;androidx.constraintlayout.widget.ConstraintLayout&amp;gt; &amp;lt;View android:id=&quot;@+id/channel_app_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;56dp&quot; android:background=&quot;#abab99&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&amp;gt; &amp;lt;View android:id=&quot;@+id/channel_app_bar_divider&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0.5dp&quot; android:background=&quot;@color/channel_app_bar_divider_color&quot; app:layout_constraintTop_toBottomOf=&quot;@id/channel_app_bar&quot;/&amp;gt; &amp;lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/message_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintTop_toBottomOf=&quot;@id/channel_app_bar_divider&quot; app:layout_constraintBottom_toTopOf=&quot;@id/view_chat_input&quot;/&amp;gt; &amp;lt;View android:id=&quot;@+id/view_chat_input&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;90dp&quot; android:background=&quot;#99abab&quot; app:layout_constraintBottom_toTopOf=&quot;@id/bottom_container&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/message_list&quot;/&amp;gt; &amp;lt;androidx.fragment.app.FragmentContainerView android:id=&quot;@+id/bottom_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#ab99ab&quot; app:layout_constrainedHeight=&quot;true&quot; app:layout_constraintHeight_max=&quot;200dp&quot; app:layout_constraintHeight_percent=&quot;0.5&quot; app:layout_constraintTop_toBottomOf=&quot;@id/view_chat_input&quot; app:layout_constraintVertical_bias=&quot;1&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; android:visibility=&quot;gone&quot;/&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;상단에는 AppBar 와 얇은 경계선이 있고,하단에는 FragmentContainerView 가 Bottom 에서부터 올라와서그 위로 InputView 가 있습니다.(TMI지만 FragmentContainerView 는 이모티콘 피커, InputText 는 텍스트 입력창이라고 보면 됩니다)그리고 RecyclerView 는 상단과 하단의 나머지 공간을 차지합니다.Android Studio 의 Design 탭에서 랜더링된 이미지는 아래와 같습니다.각 영역이 잘 연결되어있어 보이고 특별한 문제는 보이지 않습니다.잘 될까요?잘 되지만, 이상한 점이 있습니다.원하던대로 리스트의 하단부터 아이템을 쌓아올려서 스크롤이 하단에 가있습니다.한가지 문제는 스크롤이 최하단에 가있지 않는 이슈가 있습니다.스크롤을 한번 위로 튕겨줘야만 최하단 아이템이 보였습니다.분명 아래서부터 쌓아 올린거 같긴한데 뭘까요?!왜?!!아직 이유는 못찾았습니다.RecyclerView 의 높이가 결정되기 전에 아이템이 쌓이면서 뭔가 영향을 줬나 싶었는데,화면이 idle 상태에서 RecyclerView 에 데이터가 바인딩될 때도 여전히 문제가 있습니다.왜인지 언젠가 밝혀내면, 아래에 추가해두겠습니다.다행히 수정하는 방법은 찾았습니다.해결RecyclerView 의 width 를 수정하면 됩니다.As-is&amp;lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/message_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintTop_toBottomOf=&quot;@id/channel_app_bar_divider&quot; app:layout_constraintBottom_toTopOf=&quot;@id/view_chat_input&quot;/&amp;gt;To-be&amp;lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/message_list&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@id/channel_app_bar_divider&quot; app:layout_constraintBottom_toTopOf=&quot;@id/view_chat_input&quot;/&amp;gt;match_parent -&amp;gt; 0dp 로 수정했고,start &amp;amp; end to parent 제약조건을 추가했습니다.조금 황당합니다.저는 보통 width 제약이 불필요해보일 땐, match_parent 를 쓰곤 했습니다.그런데, 0dp 로 Left(Start), Right(End) 제약을 추가해줘야만내부적으로 계산이 되는 부분이 있나봅니다.예상컨데, 제약조건이 불분명해서 생긴 문제였던거 같습니다.교훈ConstraintLayout 를 LinearLayout(vertical) 느낌으로 사용할 때,ChildView 의 속성 중 아래 두가지는 다릅니다!!!!android:layout_width=&quot;match_parent&quot;android:layout_width=&quot;0dp&quot;app:layout_constraintStart_toStartOf=&quot;parent&quot;app:layout_constraintEnd_toEndOf=&quot;parent&quot;" }, { "title": "RxJava onErrorResumeNext", "url": "/posts/on_error_resume_next/", "categories": "Android, RxJava", "tags": "android, rxjava, error", "date": "2022-01-23 19:00:00 +0900", "snippet": "onErrorResumeNext 을 사용하면서 겪은 일아래와 같은 상황이 있었습니다.ChannelRepositoryImpl.javapublic class ChannelRepositoryImpl implements ChannelRepository { private final ChannelLocalDataSource local; private final ChannelRemoteDataSource remote; public Single&amp;lt;Channel&amp;gt; getChannel(String channelId) { return fetchChannel(channelId) .onErrorResumeNext(local.getChannel(channelId)); } private Single&amp;lt;Channel&amp;gt; fetchChannel(String channelId) { return remote.fetchChannel(channelId) }}간단히 설명하면, getChannel 메소드는Channel(이하 대화방) 정보를 가져오는 메소드입니다.remote 에서 정보를 가져오는데 실패한 경우,local 에 저장된 대화방 정보를 가져오는 일을 하는 메소드입니다.문제 상황remote 에서 정상적으로 대화방 정보를 가져오는 상황에서는,local.getChannel(channelId) 메소드가 실행되길 기대하지 않고 있었습니다.아래는 local.getChannel(channelId) 메소드의 구현체 부분입니다.DB 에서 데이터를 가져오는 일을 하죠.ChannelLocalDataSourceImpl 클래스의 일부입니다.@Overridepublic Single&amp;lt;Channel&amp;gt; getChannel(String channelId) { return channelDatabase.getChannel(encryptChannelId(channelId)) .map(Mapper::toChannel) .map(this::decryptChannel);}private String encryptChannelId(String channelId) { Log.d(&quot;encrypt channelId : &quot; + channelId); return BuildConfig.DEBUG ? channelId : crypto.encrypt(channelId);}정상적인 상황에서 로그를 찍어보니..encrypt channelId : blabla이 로그가 찍히는 것을 확인했습니다. 어? fetchChannel 이 정상적으로 동작했는데 Local 구현체 내부의 로그가 왜 찍히지?onErrorResumeNext 는 스트림 내에서 onError 가 발생했을 때,현재 스트림을 바꿔주는 역할을 해준다고 알고 있었습니다.따라서, 제가 기대하던 상황은 fetchChannel 이 정상적으로 동작할 때는 onErrorResumeNext 는 아무런 일도 하지 않아야 한다고 생각했습니다.그래서 로컬 데이터소스 구현체(ChannelLocalDataSourceImpl) 내부의 로그가 찍히는 일은 예상 밖의 일이었죠.내가 RxJava 를 겉핥기 식으로 알고있구나.. 반성하면서 원인을 찾아봅니다..onErrorResumeNext 를 살짝 바꿔보자기존의 onErrorResumeNext 를 조금만 바꿔보았습니다.As-isreturn fetchChannel(channelId) .onErrorResumeNext(local.getChannel(channelId));To-bereturn fetchChannel(channelId) .onErrorResumeNext(throwable -&amp;gt; local.getChannel(channelId));이렇게 수정 하니깐, 로컬 데이터소스 구현체에서 찍히던 아래 로그가 사라졌습니다.encrypt channelId : blabla &amp;lt;- 이 로그가 더이상 안찍힙니다.분명 제가 사용한 onErrorResumeNext 메소드에 차이점이 있어보입니다.이제 차이점을 한번 알아보겠습니다.원인 찾기 #1먼저 onErrorResumeNext 메소드 내부를 들여다보려고 합니다.@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.NONE)public final Single&amp;lt;T&amp;gt; onErrorResumeNext(final Single&amp;lt;? extends T&amp;gt; resumeSingleInCaseOfError) { ObjectHelper.requireNonNull(resumeSingleInCaseOfError, &quot;resumeSingleInCaseOfError is null&quot;); return onErrorResumeNext(Functions.justFunction(resumeSingleInCaseOfError));}@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.NONE)public final Single&amp;lt;T&amp;gt; onErrorResumeNext( final Function&amp;lt;? super Throwable, ? extends SingleSource&amp;lt;? extends T&amp;gt;&amp;gt; resumeFunctionInCaseOfError) { ObjectHelper.requireNonNull(resumeFunctionInCaseOfError, &quot;resumeFunctionInCaseOfError is null&quot;); return RxJavaPlugins.onAssembly(new SingleResumeNext&amp;lt;T&amp;gt;(this, resumeFunctionInCaseOfError));}이렇게 두가지가 있습니다.첫번째로는 Single 을 받고, 두번째는 Function 을 받네요.벌써부터 느낌이 조금 옵니다. 왠지 아직도 절차형 프로그래밍이 머릿 속에 남아있었던게 문제겠네요.자, 여기서 한번만 더 들어가보겠습니다.두번째 메소드 내부의 SingleResumeNext 클래스를 한번 구경해보겠습니다.관련 없는 메소드는 제거했습니다.public final class SingleResumeNext&amp;lt;T&amp;gt; extends Single&amp;lt;T&amp;gt; { final SingleSource&amp;lt;? extends T&amp;gt; source; final Function&amp;lt;? super Throwable, ? extends SingleSource&amp;lt;? extends T&amp;gt;&amp;gt; nextFunction; public SingleResumeNext(SingleSource&amp;lt;? extends T&amp;gt; source, Function&amp;lt;? super Throwable, ? extends SingleSource&amp;lt;? extends T&amp;gt;&amp;gt; nextFunction) { this.source = source; this.nextFunction = nextFunction; } @Override protected void subscribeActual(final SingleObserver&amp;lt;? super T&amp;gt; observer) { source.subscribe(new ResumeMainSingleObserver&amp;lt;T&amp;gt;(observer, nextFunction)); } static final class ResumeMainSingleObserver&amp;lt;T&amp;gt; extends AtomicReference&amp;lt;Disposable&amp;gt; implements SingleObserver&amp;lt;T&amp;gt;, Disposable { ResumeMainSingleObserver(SingleObserver&amp;lt;? super T&amp;gt; actual, Function&amp;lt;? super Throwable, ? extends SingleSource&amp;lt;? extends T&amp;gt;&amp;gt; nextFunction) { this.downstream = actual; this.nextFunction = nextFunction; } @Override public void onError(Throwable e) { SingleSource&amp;lt;? extends T&amp;gt; source; try { source = ObjectHelper.requireNonNull(nextFunction.apply(e), &quot;The nextFunction returned a null SingleSource.&quot;); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); downstream.onError(new CompositeException(e, ex)); return; } source.subscribe(new ResumeSingleObserver&amp;lt;T&amp;gt;(this, downstream)); } }}조금 길지만 간단하게 살펴보면,SingleResumeNext 의 subscribeActual 메소드를 통해서 기존 스트림을 구독하는 것으로 보입니다.여기서 nextFunction 을 통해 에러 상황에서 바꿔줄 스트림을 전달해주고,본 스트림에서 오류가 발생했을 때 ResumeMainSingleObserver 클래스의 onError 가 트리거되고,nextFunction 을 apply 하고, 바꿔줄 스트림을 subscribe 하는 모습입니다.우리의 상황에 대입해보면, fetchChannel 과정에서 exception 이 발생하게 되면,nextFunction 으로 전달한 Function 을 apply 한 뒤에, 구독하여결과적으로 onErrorResumeNext 에 작성한 스트림으로 이어서 진행하게 되겠죠.원인 찾기 #2 (기대대로 동작하는 코드)기대대로 동작하던 코드를 다시 보겠습니다.return fetchChannel(channelId) .onErrorResumeNext(throwable -&amp;gt; local.getChannel(channelId));여기서 throwable -&amp;gt; local.getChannel(channelId) 는 Function 인터페이스를 구현해서 람다로 표현한 모습입니다.public interface Function&amp;lt;T, R&amp;gt; { /** * Apply some calculation to the input value and return some other value. * @param t the input value * @return the output value * @throws Exception on error */ R apply(@NonNull T t) throws Exception;}즉, 우리는 throwable 을 받아서 SingleSource 를 리턴해주는 apply 라는 메소드를 구현한 것입니다.이 람다를 펼쳐서 작성하면 아래와 같습니다.@Overridepublic Single&amp;lt;Channel&amp;gt; getChannel(String channelId) { final Function&amp;lt;Throwable, SingleSource&amp;lt;? extends Channel&amp;gt;&amp;gt; resumeFunction = new Function&amp;lt;Throwable, SingleSource&amp;lt;? extends Channel&amp;gt;&amp;gt;() { @Override public SingleSource&amp;lt;? extends Channel&amp;gt; apply(@NonNull Throwable throwable) throws Exception { return local.getChannel(channelId); } }; return fetchChannel(channelId) .onErrorResumeNext(resumeFunction);}원인 찾기 #1 에서 봤듯이, onError 가 발생한 뒤에 apply 를 하고 바뀐 스트림을 subscribe 하기 때문에,fetchChannel 이 정상적으로 동작했을 때는 로컬 데이터소스 구현체에서 아래 로그가 찍히지 않았던 것이죠.encrypt channelId : blabla &amp;lt;-- 이 로그가 찍히지 않습니다.기대대로 동작하는 코드가 왜 그렇게 동작했는지 살펴봤습니다.원인 찾기 #3 (기대대로 동작하지 않았던 코드)그러면, 처음의 문제상황return fetchChannel(channelId) .onErrorResumeNext(local.getChannel(channelId));이 코드는 fetchChannel 이 정상적인 상황에서도 왜 아래 로그가 찍혔던 것일까요?encrypt channelId : blabla위에서 살펴봤던 Single 을 받는 onErrorResumeNext 메소드에서Functions.justFunction(resumeSingleInCaseOfError) 를 보겠습니다.@CheckReturnValue@NonNull@SchedulerSupport(SchedulerSupport.NONE)public final Single&amp;lt;T&amp;gt; onErrorResumeNext(final Single&amp;lt;? extends T&amp;gt; resumeSingleInCaseOfError) { ObjectHelper.requireNonNull(resumeSingleInCaseOfError, &quot;resumeSingleInCaseOfError is null&quot;); return onErrorResumeNext(Functions.justFunction(resumeSingleInCaseOfError));}여기서 justFunction 을 보면..public static &amp;lt;T, U&amp;gt; Function&amp;lt;T, U&amp;gt; justFunction(U value) { return new JustValue&amp;lt;T, U&amp;gt;(value);}전달한 value 를 들고 있는 Function 인스턴스 를 만들어 주고 있습니다.여기서 전달한 value 는 local.getChannel(channelId) 입니다.즉, 에러 상황에서 바꿔줄 스트림(local.getChannel(channelId))을 값으로 갖는Function 인스턴스를 만들어두기 때문에 로컬 데이터소스 구현체의 로그가 찍히는 것입니다.물론, 이 바꿔줄 스트림을 apply 하고 subscribe 를 하는 일은 본 스트림에서 onError 가 발생한 뒤의 일입니다.바꿔줄 스트림을 구독하기 전까지의 일은 fetchChannel 의 오류 여부와 무관하게 진행했고, 그래서 로그가 찍현던 것입니다.조금더 극단적으로 눈에 보이게 표현하면..@Overridepublic Single&amp;lt;Channel&amp;gt; getChannel(String channelId) { return fetchChannel(channelId) .onErrorResumeNext(local.getChannel(channelId));}위의 코드는 아래와 같습니다.@Overridepublic Single&amp;lt;Channel&amp;gt; getChannel(String channelId) { return fetchChannel(channelId) .onErrorResumeNext(new JustValue&amp;lt;&amp;gt;(local.getChannel(channelId)));}static final class JustValue&amp;lt;T, U&amp;gt; implements Callable&amp;lt;U&amp;gt;, Function&amp;lt;T, U&amp;gt; { final U value; JustValue(U value) { this.value = value; } @Override public U call() throws Exception { return value; } @Override public U apply(T t) throws Exception { return value; }}Function 인터페이스를 구현한 JustValue 인스턴스를 만들어서 onErrorResumeNext 에 넣어주는 일은본 스트림의 onError 발생 여부와 무관하게 해야하는 일입니다.JustValue 인스턴스를 만들기 위해서는 local.getChannel(channelId) 메소드는 실행되어야하죠.물론, 본 스트림에서 에러가 발생 전까지는 구독하지 않구요.차가운 옵저버블은 구독하기 전까지는 어짜피 데이터 발행을 하지 않으니까,구독하기 전까지의 일은 다해놨다 라고 보면 되지 않을까 싶습니다.정리onErrorResumeNext(…) 안에 Single 을 넘겨준다면,해당 Single 을 구독하기 전에 내부적으로 문제가 될 만한 부분이 있는지 체크해봐야겠습니다." }, { "title": "자주쓰는 ConstraintLayout 속성(2)", "url": "/posts/constraint_layout_2/", "categories": "Android, xml", "tags": "android, constraintlayout, layout", "date": "2022-01-17 19:00:00 +0900", "snippet": "ConstraintLayout이전 포스트 내용을 말로 풀면 아래와 같습니다. 이름은 최대한 전부 다 표현해주고, 닉네임의 최소 너비(100dp)는 보장해준다.이번에는 close 아이콘을 닉네임 옆에 붙어있도록 하는 방법을 알아봅니다.close 아이콘은 닉네임 옆에 붙어있으면서, 우측 끝에 닿으면 이름과 닉네임이 말줄임 표시가 되고,close 아이콘은 항상 보여아합니다.nickname 의 width 변경지금은 width 의 남은 영역을 nickname 이 모두 가져가고 있습니다.close 아이콘을 nickname 바로 옆에 위치시키려면,먼저 nickname 의 width 를 wrap_content 로 변경해줍니다.&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:padding=&quot;10dp&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintWidth_min=&quot;100dp&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/btn_box_close&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;name 과 nickname 이 모두 wrap_content 속성을 갖고 있어서남는 너비를 나눠갖는 모습입니다.코드를 자세히 보면,name 은 왼쪽으로는 parent, 오른쪽으로는 nickname 과 연결되어있고nickname 은 왼쪽으로는 name, 오른쪽으로는 close 와 연결되어 있습니다.그리고 close 는 오른쪽으로 parent 만 연결되어 있습니다.close 에 왼쪽 제약 조건 추가이제는, close 버튼을 단순히 우측에 배치만 하면 안되고 왼쪽 뷰들과 제약관계를 맺어야하기 때문에close 버튼에 layout_constraintStart_toEndOf 조건을 추가해줍니다.&amp;lt;ImageView android:id=&quot;@+id/close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/btn_box_close&quot; app:layout_constraintStart_toEndOf=&quot;@id/nickname&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;이제 3개의 뷰가 모두 start, end 로 연결이 되어있습니다.모아서 좌측 정렬각 뷰들이 좌측으로 모아져서 정렬되도록 하려면,chain 과 bias 를 알아야합니다.Android Developer chain-style 가이드우리가 필요한 기능은 Packed Chain with Bias 로 표현이 가능할 것 같습니다.&amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintHorizontal_bias=&quot;0&quot;/&amp;gt;제약 조건의 첫번째 뷰인 name 에 horizontal chainStyle 을 packed 로 주고,bias 를 0으로 설정합니다.packed 속성으로 뷰들이 모아지고, bias 속성으로 좌우 균형을 깨고, 왼쪽으로 몰아두었습니다.bias 속성은 0~1 사이 값을 넣어주며, 0 이면 좌측, 1 이면 우측으로 붙습니다.그 사이값을 실무에서 사용할 일은 없었습니다.닉네임의 layout_constraintWidth_min 제거닉네임 옆에 바로 붙여야하는데, layout_constraintWidth_min 설정 때문에닉네임과 close 사이에 여백이 보여서 제거해줍니다.&amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot; /&amp;gt;몇가지 케이스에서는 이상적으로 동작하는데,닉네임을 wrap_content 로 변경하면서 닉네임이 길어지는 경우 이름 영역까지 잡아먹는 현상이 발생합니다.선택에 따라 간단히 대응할 수 있습니다.1. name 에 min width 를 주는 방법name 속성에 최소너비를 주변 간단히 해소 가능합니다.다만, 이름이 외자거나.. 예외상황에서 자칫 이름과 닉네임 간격이 다르게 보이면 사용자가 이질감을 느낄 수 있습니다.2. nickname 에 max width 를 주는 방법layout_constraintWidth_max 또는 maxEms 등을 사용하는 것도 한 방법입니다.3. Depth 를 하나 추가하는 방법이전 포스트에서 nickname 에 min width 를 100dp 로 설정했던 것을 활용하는 방법입니다.nickname 과 close 버튼을 붙여야해서, 위에서 nickname 의 min width 를 제거했는데,nickname 과 close 버튼을 묶어서 또 다른 ConstraintLayout 에 넣어주고,ConstraintLayout 의 min width 를 120dp(100dp + close 아이콘 크기) 로 설정하는 방법입니다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:padding=&quot;10dp&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname_close_container&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintHorizontal_bias=&quot;0&quot; /&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout android:id=&quot;@+id/nickname_close_container&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintWidth_min=&quot;120dp&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot; &amp;gt; &amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;packed&quot; app:layout_constraintHorizontal_bias=&quot;0&quot;/&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/btn_box_close&quot; app:layout_constraintStart_toEndOf=&quot;@id/nickname&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&amp;gt; &amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;코드를 보면,내부에 추가한 ConstraintLayout 안에 chainStyle 과 bias 로닉네임과 close 버튼을 묶어서 좌측으로 보냈습니다.그리고 이 내부의 ConstraintLayout 에 layout_constraintWidth_min 를 지정했습니다.몇가지 상황에서 아래와 같이 동작합니다.정리아직 ConstraintLayout 속성을 100% 이해하지 못한 점도 있고,저런 상황에서 완벽히 동작하려면 동적으로 핸들링을 해야만 하나? 싶은 생각도 듭니다.더 알아봐야합니다..만 이 정도로도 코너케이스를 제외하면 충분히 커버가 가능해보입니다.혹시 더 나은 활용법이 있으면 알려주세요!" }, { "title": "자주쓰는 ConstraintLayout 속성", "url": "/posts/constraint_layout/", "categories": "Android, xml", "tags": "android, constraintlayout, layout", "date": "2022-01-17 09:00:00 +0900", "snippet": "ConstraintLayout레거시한 코드가 아니라면 레이아웃 파일에 꼭 들어가는 ConstraintLayout.일반적인 화면 구성에는 어려울 것 없지만,간혹 복잡한 레이아웃(예를 들면, 가변 텍스트가 수평배치되는 등..)에서는조금 더 잘 알고 쓰면,Layout depth 를 최대한 적게 유지할 수 있습니다.이름, 별명, 아이콘이 수평 배치이런 화면을 구성한다고 생각해봅시다.&amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&amp;gt;&amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt;&amp;lt;ImageView android:id=&quot;@+id/close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/btn_box_close&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;상위의 ConstraintLayout 을 생략하면 대략 이런 형태가 될겁니다.그런데, 문제가 있습니다.이렇게 이름이 긴 경우, 또는 닉네임이 긴 경우 대비를 해야겠습니다.name 영역의 좌우 제약 정리기존에는 start 제약만 추가되어있습니다.nickname 과의 연결을 위해constraintEnd_toStartOf 조건을 추가해줍니다.한줄로 표현해주려고, maxLines 옵션도 추가합니다.&amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동&quot; android:maxLines=&quot;1&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;nickname 영역의 좌우 제약 정리마찬가지로, nickname 영역도 end 제약을 추가해줍니다.&amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt;여기까지 진행하면 아래와 같이 표현됩니다.name 영역 정리한줄로 잘 배치가 됐지만, 이름의 끝이 잘렸으나 인지하기 어렵습니다.ellipsize 옵션을 넣어서 말줄임 표시를 추가해줍니다.&amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;nickname 영역이 길어지면?닉네임 영역이 길어지면, 이름이 사라지게 됩니다.이유는 nickname 뷰가 wrap_content 를 사용하고 있기 때문입니다.nickname 의 width 를 0dp 로 바꿔주고,줄바꿈을 방지하기위해 maxLines 와 ellipize 옵션도 추가해줍니다.&amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차으라차차으라차차으라차차으라차차으라차차으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt;자, 이제 가변인 name 과 nickname 이 길어져도 한 줄에 잘 표현이 됩니다.사실 흔한 케이스는 아니지만, 이름이 긴 외국인이 사용하거나, nickname 에 다른 정보들을 넣어서 내용이 길어지는 경우를 잘 핸들링 할 수 있습니다.name 이 짧아질 때?!이름이 짧아졌을 때 여백이 생겼습니다.name, nickname 이 모두 0dp width 와 동일한 제약조건으로 연결되어있으니어찌보면, 공평하게 나눠갖는게 맞습니다.이름 옆에 닉네임이 붙어서 보이는게 일반적이니,이름을 다시 wrap_content 로 수정합니다.단, wrap_content 속성만 사용한다면 이름이 길어질 때 길어진대로 이름을 감싸기만 합니다.즉, 화면을 벗어난채로 쭉쭉 길어만 지게 되죠.그래서 layout_constrainedWidth : true 조건을 넣어줍니다.보통은 wrap 으로 보여주고, 제약 조건이 필요한 시점에는 마치 0dp 로 설정했을 때 처럼 동작하게해서 화면 밖으로 벗어나는 것을 막아줍니다.&amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;이름 옆으로 닉네임이 잘 붙어서 보입니다.다만, 조건을 변경한 채로 다시 이름을 길게 설정하면닉네임의 공간이 확보가 안되는 문제가 생깁니다.몇가지 방법이 있겠지만, 보통 정보의 우선순위가 이름 &amp;gt; 닉네임 이라고 생각해서닉네임의 최소 width 를 보장하는 정도로 처리합니다.layout_constraintWidth_min 을 100dp 정도로 설정해줍니다.&amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintWidth_min=&quot;100dp&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt;정리&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:padding=&quot;10dp&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;홍길동&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constrainedWidth=&quot;true&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintEnd_toStartOf=&quot;@id/nickname&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt; &amp;lt;TextView android:id=&quot;@+id/nickname&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;으라차차&quot; android:maxLines=&quot;1&quot; android:ellipsize=&quot;end&quot; app:layout_constraintWidth_min=&quot;100dp&quot; app:layout_constraintStart_toEndOf=&quot;@id/name&quot; app:layout_constraintEnd_toStartOf=&quot;@id/close&quot; app:layout_constraintTop_toTopOf=&quot;@id/name&quot; android:layout_marginStart=&quot;10dp&quot;/&amp;gt; &amp;lt;ImageView android:id=&quot;@+id/close&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/btn_box_close&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&amp;gt;&amp;lt;/androidx.constraintlayout.widget.ConstraintLayout&amp;gt;가로로 배치되는 텍스트의 가변 케이스를 ConstraintLayout 으로 표현해봤습니다.다음에는, close 아이콘이 닉네임의 우측에 붙어 있는 방법을 알아보겠습니다!" } ]
